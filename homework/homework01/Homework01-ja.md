宿題1
=====

この宿題は「プログラミングHaskell」の第1～4章を扱っています。

問題1
-----

地震のマグニチュードを比べる関数`magComp`を定義せよ。

    magComp :: Float  -- 地震1のマグニチュード
            -> Float  -- 地震2のマグニチュード
            -> Float  -- 地震1が何倍強い

例えば、M9の地震がM7の地震の1000倍強い。

http://ja.wikipedia.org/wiki/マグニチュード

    > magComp 9 7
    1000.0

ヒント：`(^)`という関数の型を調べると、指数には*Integral*しか使えないことが
わかる。ここでは`(**)`という関数を使うと良い。こちらは指数として実数も使える。
いずれの関数も*Prelude*で定義されている。型についてはGHCiの`:t`コマンドで確認
すると良い。

以下の実行例で自分の定義が正しいことを確認せよ。

    > magComp 7.0 6.2
    15.848943
    > magComp 6.8 7.0
    0.50118756

問題2
-----

(1) 近似等価性を検査する関数`approxEq`を定義せよ。

    approxEq :: Float  -- Δ
             -> Float  -- 値1
             -> Float  -- 値2
             -> Bool   -- 値2 ∈ (値1 - Δ, 値1 + Δ)

ヒント：`(a, b)`は境界を含まない下限`a`、上限`b`の領域

以下の実行例で自分の定義が正しいことを確認せよ。

    > approxEq 0.01 0 0.01
    False
    > approxEq 0.01 0 0.0099
    True
    > approxEq 0.001 (22 / 7) pi
    False
    > approxEq 0.01 (22 / 7) pi
    True

(2) Δを`0.0001`に設定して近似等価関数`approxEq'`はカリー化を用いて以下のように
定義できる：

    approxEq' :: Float  -- 値1
              -> Float  -- 値2
              -> Bool   -- 値2 ∈ (値1 - 0.0001, 値1 + 0.0001)
    approxEq' = approxEq 0.0001

以下の実行例で自分の定義が正しいことを確認せよ。

    > (99 / 70) `approxEq'` (sqrt 2)
    True

(3) カリー化を使って、引数が0±0.0001以内か検査する関数`approxZero`を定義せよ。

    approxZero :: Float  -- 値
               -> Bool   -- 値 ∈ (-0.0001, 0.0001)

以下の実行例で自分の定義が正しいことを確認せよ。

    > approxZero (-1 / 999)
    False
    > approxZero (0.5 ^ 14)
    True

問題3
-----

動画のファイルの（近似）画像圧縮率を計算する関数`compLevel`を定義せよ。

    compLevel :: (Int, Int)  -- 幅（ピクセル）, 高さ（ピクセル）
              -> Float       -- フレームレート（フレーム／秒）
              -> Int         -- 時間（秒）
              -> Float       -- オーディオ・ビットレート（Kb／秒）
              -> Float       -- ファイルサイズ（MiB）
              -> Float       -- 画像圧縮率

この問題では、動画の画像圧縮率とは非圧縮ビデオのビットレート÷圧縮された
ビデオのビットレートとする。24ビット／ピクセルの色震度を仮定する。単位を
間違えないように注意を払う必要がある。ファイルサイズはメビバイト（MiB）
（1024×1024バイト）で数えるが、ビットレートの方はキロビット
（1000ビット）／秒で計算する。

以下の実行例で自分の定義が正しいことを確認せよ。

    > compLevel (720, 480) (30000 / 1001) (120 * 60) 128 700
    361.5448
    > compLevel (352, 288) 25 (120 * 60) 128 700
    88.466

問題4
-----

第2章で紹介した関数を使って、リストの最初と最後以外の要素を逆順にする関数
`revmid`をその型とともに定義せよ。

以下の実行例で自分の定義が正しいことを確認せよ。

    > revmid []
    []
    > revmid [1,2]
    [1,2]
    > revmid [1,2,3,4,5]
    [1,4,3,2,5]

問題5
-----

親戚の集まりで、地震研究関係の仕事をしている義理の姉からある問題について相談
された。本質的には、三角柱の頂点の順序を確認するという問題であった。ただし、
三角柱は3次元空間で任意の向きになっていて良いとする。各頂点は添付した図に
示した順になっている必要がある。

この問題を解くプログラムをHaskellで作成せよ。座標系は右手系（親指X軸、人差し指
Y軸、中指Z軸）を用いよ。

    isValidTP :: (Float, Float, Float)  -- 頂点1 (X,Y,Z)
              -> (Float, Float, Float)  -- 頂点2 (X,Y,Z)
              -> (Float, Float, Float)  -- 頂点3 (X,Y,Z)
              -> (Float, Float, Float)  -- 頂点4 (X,Y,Z)
              -> (Float, Float, Float)  -- 頂点5 (X,Y,Z)
              -> (Float, Float, Float)  -- 頂点6 (X,Y,Z)
              -> Bool                   -- 正しい順のとき真

以下の実行例で自分の定義が正しいことを確認せよ。

    > isValidTP (2,0,0) (2,2,0) (0,2,2) (0,0,2) (-2,2,0) (-2,0,0)
    True
    > isValidTP (2,0,0) (2,-2,0) (0,-2,-2) (0,0,-2) (-2,-2,0) (-2,0,0)
    True
    > isValidTP (2,0,0) (2,2,0) (0,2,2) (0,0,2) (-2,0,0) (-2,2,0)
    False
    > isValidTP (2,0,0) (2,-2,0) (0,-2,-2) (0,0,-2) (-2,0,0) (-2,-2,0)
    False
    > isValidTP (0,0,1) (0,1,1) (1,1,0) (1,0,0) (-1,1,0) (-1,0,0)
    False

コメント：座標の表現に今回はタプルを使ったが、データ型を用いてこのコードを
すっきりさせるやり方をいずれ学ぶ。
